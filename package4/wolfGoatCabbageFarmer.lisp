;;;======================================================================================
;;; History
;;; Once upon a time a farmer went to a market and purchased a wolf, a goat, and a cabbage. 
;;; On his way home, the farmer came to the bank of a river and rented a boat. But crossing 
;;; the river by boat, the farmer could carry only himself and a single one of his 
;;; purchases: the wolf, the goat, or the cabbage.
;;; If left unattended together, the wolf would eat the goat, or the goat would eat the 
;;; cabbage.
;;; The farmer's challenge was to carry himself and his purchases to the far bank of the 
;;; river, leaving each purchase intact. How did he do it?
;;; wolfGoatCabbageFarmer.lisp
;;;
;;;     Solve the wolf, goat, cabbage and farmer's problem using blind search, breath first and depth first.
;;;
;;;     Note: As the only way to go from one riverbank to other, we are going to merge the boat and farmer in one value
;;;     States representation:
;;;         A list with two sublist, one for each riverbank
;;;         In each riverbank, Farmer/Boat(F), Cabbage(C), Goat(G), Wolf(W)
;;;                 Initial state:             Target state:
;;;                  F C G W   F C G W           F C G W   F C G W
;;;                ((1 1 1 1) (0 0 0 0))       ((0 0 0 0) (1 1 1 1))
;;;
;;;     Oscar Martinez Vazquez
;;;     Artificial Intelligence Fundamentals
;;;     Centro de Investigacion en Computo
;;;  March, 2021
;;;======================================================================================
(defparameter  *open* '()) ;; Search frontier                                             
(defparameter  *memory* '()) ;; Past attempts memory

(defparameter  *ops*  '( 
	(:Farmer			    (1 0 0 0))
	(:Farmer-and-Cabbage	(1 1 0 0))
	(:Farmer-and-Goat	    (1 0 1 0))
	(:Farmer-and-Wolf		(1 0 0 1))))

(defparameter  *id*  -1) ;; Last created node id
(defparameter  *current-ancestor*  nil) ;; Root node id of all generated children
(defparameter  *solution*  nil) ;; List of the solution (generated by backtracking)
(defparameter *maxLengthOfOpen* 0) ;; Length of *open* list

;;;=======================================================================================
;;  CREATE-NODE (state  op)  
;;      state - An state of the problem (system)
;;         op - Operator wich application generates the [state]...
;;;=======================================================================================
(defun  create-node 
	(state  op)
    "Creates new node with the state and operator as parameters"
    (incf  *id*)
    (list  *id*  state  *current-ancestor*  (first op)))  ;; The nodes generated are children of *current-ancestor*

;;;=======================================================================================
;;  INSERT-TO-OPEN and GET-FROM-OPEN  
;;        Insert-to-open  receives a list and key - the key map the function to append the state
;;             :depth-first     Inserta los elementos de la lista en orden inverso y por el inicio de la lista
;;             :breath-first    Inserta los elementos de la lista en orden normal y por el final de la lista
;;        Get-from-open  siempre retira el primer elemento de la lista *open*
;;;=======================================================================================
(defun insert-to-open 
	(state  op  method)
    "Allow to insert nodes in the search frontier *open* depending on method parameter (breath-first or depth-first)"
    (let (
        (node  (create-node  state  op)))
        (cond 
			((eql  method  :depth-first)
	        	(push  node  *open*))
	    	((eql  method  :breath-first)
				(setq *open*  (append  *open*  (list node))))
	   	   	(T  Nil))
		)
	)

(defun get-from-open 
	()
    "Recover the next element to check in the search frontier *open*"
    (pop  *open*))

;;;=======================================================================================
;;  BARGE-SHORE (state)
;;      Return the bank river where is the farmer
;;          0 - Initial riverbank (fisrt sublist of the state)
;;          1 - Target riverbank (second sublist of the state)
;;;=======================================================================================
(defun barge-shore 
	(state)
    "Return the riverbank where is the farmer 0 - Initial 1 - Target"
    (if
		(= 1 (first (first  state)))  
		0  
		1)
	)

;;;=======================================================================================
;;  VALID-OPERATOR [op, state]
;;        Indicate if is possible to apply the [op] to [state]
;;;=======================================================================================
(defun  valid-operator? 
	(op  state)
	"Validate the application of the operator to the state
	State structure:  [(<f0><c0><g0><w0>) (<f1><c1><g1><w1>)],
	Operator: [<human-label> <list operator(<num farmer><num cabbage><num goat><num wolf>)>]"  
	(let* (
		(riverbank (barge-shore state))                         
	    (farmer (first (nth  riverbank state)))   
	    (cabbage (second (nth  riverbank state)))
        (goat (third (nth riverbank state)))
        (wolf (fourth (nth riverbank state))))
        (and
			(>= farmer (first (second op)))
            (>= cabbage (second (second op)))
            (>= goat (third (second op)))
            (>= wolf (fourth (second op))))
		)
	)

;;;=======================================================================================
;;  VALID-STATE (state)
;;      Indicate if [state] is valid according to the restrictions of the problem
;;      If in any of the riverbanks there is not goat-cabbage or goat-wolf combination
;;;=======================================================================================
(defun flip 
	(bit)
	(boole BOOLE-XOR  bit  1))

(defun  valid-state? 
	(state)
	"Validate the state according to problem restrictions
	State structure:  [(<f0><c0><g0><w0>) (<f1><c1><g1><w1>)]"
    (let* (
        (riverbank  (flip (barge-shore  state))) 
	    (cabbage (second (nth  riverbank state)))
        (goat (third (nth riverbank state)))
        (wolf (fourth (nth riverbank state))))
		(not (and
            (equal 1 goat)
            (or
                (equal 1 cabbage)
                (equal 1 wolf))
		    )
        ))
	)

;;;=======================================================================================
;;  APPLY-OPERATOR (op, state)
;;        Change the state of the system
;;;=======================================================================================
(defun  apply-operator 
	(op  state) 
	"Get the [states]'s child applying the [op] WITHOUT RESTRICTIONS"
    (let* (
		(riverbank1  (first  state))
		(riverbank2  (second  state))
		(f0 (first riverbank1))
		(c0 (second riverbank1))
		(g0 (third riverbank1))
        (w0 (fourth riverbank1))
		(f1 (first riverbank2))
		(c1 (second riverbank2))
		(g1 (third riverbank2))
        (w1 (fourth riverbank2))
		(operator (first op))) ;; Human label of the operator
	 	(case operator
	    	(:Farmer
                (list  
					(list (flip f0) c0 g0 w0)   
					(list (flip f1) c1 g1 w1))
				)
	    	(:Farmer-and-Cabbage
                (list  
					(list (flip f0) (flip c0) g0 w0)   
					(list (flip f1) (flip c1) g1 w1))
				) 
	    	(:Farmer-and-Goat
                (list  
					(list (flip f0) c0 (flip g0) w0)   
					(list (flip f1) c1 (flip g1) w1))
				)
	    	(:Farmer-and-Wolf
                (list  
					(list (flip f0) c0 g0 (flip w0))   
					(list (flip f1) c1 g1 (flip w1)))
				)
	    	(T "error"))
		)
	)

;;;=======================================================================================
;;  EXPAND (state)
;;      Build and return a list with all valid parents of [state]
;;;=======================================================================================
(defun expand 
	(state)
    "Get all valid children of state, aplying the operators *ops* in the same order"
    (let (
		(children  nil)
		(new-state  nil))
        (dolist  
			(op  *Ops*  children) 
	        (setq new-state (apply-operator  op state))  ;; Apply the oprator then...
			(when
				(and
					(valid-operator? op state)           ;; validate it
					(valid-state? new-state))
	            (setq children (cons (list new-state op) children)))
			)
		)
	)

;;;=======================================================================================
;;  REMEMBER-STATE? and FILTER-MEMORIES
;;      Allow to manage the previous attempts memory
;;;=======================================================================================
(defun remember-state? 
	(state memory-list)
    "Search an state in the list, this list works as previous attemps memory
    State structure: [(<f0><c0><g0><w0>) (<f1><c1><g1><w1>)]
    Node structure: [<Id> <state> <id-parent> <operator>]"  
    (cond 
		((null memory-list)  
			NIL)
	    ((equal state  (second (first memory-list)))  
			T) ;; The state is equal than the node state?
		(T  
			(remember-state?  state (rest  memory-list))))
	)

(defun  filter-memories 
    (states-and-ops)
    "Filter a list of states-and-operations removing the elements that are in the memory *memory*
    states-and-ops structure:[(<estado> <op>) (<estado> <op>) ... ]"
    (cond 
	 	((null  states-and-ops) Nil)
	    	((remember-state? (first (first  states-and-ops)) *memory*) ;; If remember the first element of the list filter it...
		    (filter-memories (rest  states-and-ops)))
		(T  (cons  (first states-and-ops) 
			(filter-memories (rest  states-and-ops)))) ;; in other case, added it to the answer
		) 
	)

;;;=======================================================================================
;;  EXTRACT-SOLUTION and DISPLAY-SOLUTION
;;       Recover and show the solution sequence of the problem...
;;       extract-solution Receives a node (with the target state) that is in memory and backtrack the parents until the initial state
;;       display-solution Show on screen the global list *solution* where already is and in correct order the solution of the problem
;;;=======================================================================================
(defun extract-solution 
	(node)
    "Backtrack in *memory* all the parents of [node] until the initial state"
    (labels (
		(locate-node (id list)       ;; funciÃ³n local que busca un nodo por Id  y si lo encuentra regresa el nodo completo
		(cond 
			((null list) Nil)
		    	((eql  id  (first (first list))) (first list))
		    (T  
				(locate-node  id (rest list)))))
		)
	  	(let (
			(current (locate-node (first  node)  *memory*)))
			(loop  while  (not (null  current))  do                        
				(push current *solution*) ;; Add the current node to the solution
				(setq current (locate-node (third current) *memory*))) ;; then change the parent...
			)
	    *solution*)
	)

(defun  display-solution 
	(nodes-list last-node method)
    "Display in a formatted and numerated way the solution"
	(format T "Search method: ~d~%" method)
	(format T "Total nodes: ~d~%" last-node)
	(format T "Total proccessed nodes: ~d~%" (length *memory*))
	(format T "Max lenght of frontier search : ~d~%" *maxLengthOfOpen*)
    (format t "Solution with ~A  steps:~%~%" (1- (length  nodes-list)))
    (let (
		(node nil))
        (dotimes 
			(i (length nodes-list))
			(setq node (nth  i  nodes-list))
	      	(if  
				(= i 0)
				(format t "Starts on: ~A~%" (second node)) ;; From this initial states
		   		(format t "\( ~2A\)  applying ~20A go to ~A~%"  i (fourth  node)  (second  node))) ;; print the step, operator and state
			)
		)
	)

;;;=======================================================================================
;;  RESET-ALL and BLIND-SEARCH
;;      Recall and show the solution sequence of the problem
;;          reset-all Reset all  global variables for new executions
;;          bind-search Main function, executes the search from initial state to target state
;;;=======================================================================================
(defun reset-all 
	() 
	"Reset all global variables to execute a new blind-search..."
	(setq  *open*  NIL)
	(setq  *memory*  NIL)
	(setq  *id*  0)
	(setq  *current-ancestor*  NIL)
	(setq  *solution*  NIL))

(defun  blind-search 
	(initial-state target-state method)
	"Executes a blind-search with the specified method from initial to target state
    available methods:  :depth-first
                        :breath-first"
  	(reset-all)
  	(let (
		(node nil)
	  	(state nil)
	  	(children  '())
	  	(operator  nil)
	  	(target-found  nil))
      	(insert-to-open initial-state nil method)
      	(loop until 
			(or 
				target-found
    	    	(null *open*))  
			do
			(setq 
				node (get-from-open) ;; Get the next node in the search frontier
				state (second  node) ;; Identify the state and operator
				operator (third  node))          
	   		(push  node  *memory*) ;; Save it if something happend
			(if
				(> (length *open*) *maxLengthOfOpen*)
				(setf *maxLengthOfOpen* (length *open*))
			)
	   		(cond 
			   	((equal target-state state)
		            (display-solution  (extract-solution  node) (first node) method)
		            (setq  target-found  T))
		        (t
					(setq  *current-ancestor*  (first  node)) 
			    	(setq  children  (expand state))
			     	(setq  children  (filter-memories  children)) ;; Filter states that already have been proccesed
			      	(loop for  element  in  children  do
				    	(insert-to-open  (first element)  (second element)  method)))
				)
			)
		)  
	)
  
;;;=======================================================================================
;;;=======================================================================================

;;; Execution sentence: sbcl --script wolfGoatCabbageFarmer.lisp
(time (blind-search '((1 1 1 1)(0 0 0 0)) '((0 0 0 0)(1 1 1 1)) :depth-first))
(time (blind-search '((1 1 1 1)(0 0 0 0)) '((0 0 0 0)(1 1 1 1)) :breath-first))